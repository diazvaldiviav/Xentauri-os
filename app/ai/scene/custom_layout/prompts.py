"""
Custom Layout Prompts - HTML generation from content data.

Architecture:
=============
- Gemini = CONTENT (what to show, real data) - generated by backend
- Claude/Opus = DESIGN (how to show it) - full creative freedom

Sprint 6.1: Direct data flow without SceneGraph intermediate format.
"""

import json
from typing import Dict, Any, Optional


def build_data_to_html_prompt(
    content_data: Dict[str, Any],
    user_request: str,
    layout_hints: Optional[str] = None,
) -> str:
    """
    Build prompt for HTML generation from content data (no SceneGraph).

    This is the optimized flow where Gemini generates content data directly
    and Opus creates HTML without the SceneGraph intermediate format.

    Args:
        content_data: Content data from Gemini (type, title, data)
        user_request: Original user request
        layout_hints: Optional layout hints from intent parser

    Returns:
        Prompt string for Opus HTML generation
    """
    hints_section = ""
    if layout_hints:
        hints_section = f"\n## Layout Hints\n{layout_hints}\n"

    return f"""## Request
"{user_request}"
{hints_section}
## Content Data (use this exactly)
```json
{json.dumps(content_data, ensure_ascii=False, indent=2, default=str)}
```

## Output
Complete standalone HTML (<!DOCTYPE html> to </html>).
Target: 1920x1080 dark theme touchscreen display.
"""


def build_custom_layout_prompt(scene: Dict[str, Any], user_request: str = None) -> str:
    """
    Build prompt for Claude to generate custom HTML layout.

    Args:
        scene: SceneGraph with content data
        user_request: Original user request for context

    Returns:
        Prompt string
    """
    if not user_request:
        metadata = scene.get("metadata", {})
        user_request = metadata.get("user_request", "Display content")

    # Extract content from SceneGraph
    global_style = scene.get("global_style", {})
    layout = scene.get("layout", {})
    components = scene.get("components", [])
    animation_hints = scene.get("animation_hints", [])
    scroll_hints = scene.get("scroll_hints", [])

    # Build content summary
    content_data = {
        "user_request": user_request,
        "layout_intent": layout.get("intent", "fullscreen"),
        "style": {
            "background": global_style.get("background", "#0f0f23"),
            "text_color": global_style.get("text_color", "#ffffff"),
            "accent": global_style.get("accent_color", "#7b2cbf"),
        },
        "content": [
            {"type": comp.get("type"), "data": comp.get("data", {})}
            for comp in components
        ],
    }

    if animation_hints:
        content_data["animation_hints"] = animation_hints
    if scroll_hints:
        content_data["scroll_hints"] = scroll_hints

    prompt = f"""## Request
"{user_request}"

## Content (use this data, design freely)
```json
{json.dumps(content_data, ensure_ascii=False, indent=2, default=str)}
```

## Output
Complete standalone HTML (<!DOCTYPE html> to </html>).
Target: 1920x1080 dark theme display.
"""

    return prompt


def get_system_prompt() -> str:
    """System prompt for HTML generation."""
    return """You are an expert HTML/CSS/JS designer.

You receive CONTENT (what to display) and you CREATE the visual experience (how to display it).

The content data is your source material - use it to build something beautiful and engaging.
You have full creative freedom on design, layout, animations, and interactivity.

Use modern web features: CSS flexbox, grid, animations, :has(), scroll-snap.
Use JavaScript when needed for interactivity (quizzes, games, dynamic content).
Make it visually stunning and interactive.

Technical constraints:
- Standalone HTML with inline CSS/JS
- Target: 1920x1080 touchscreen

REQUIRED DATA ATTRIBUTES for interactive content (MUST use these for validation):

For TRIVIA/QUIZ:
- data-trivia="container" on main container
- data-question="N" on each question container (N = question number)
- data-option on each answer option/button
- data-submit on the submit/next button
- data-score on the score display element
- data-feedback on correct/incorrect feedback elements

For GAMES:
- data-game="container" on game container
- data-start on start/play button
- data-score on score display
- data-lives on lives/health display (if applicable)
- data-restart on restart/play-again button

For DASHBOARDS:
- data-dashboard="container" on main container
- data-filter on filter controls
- data-metric on KPI/metric displays
- data-chart on chart containers

INTERACTION REQUIREMENTS (for visual validation):

CRITICAL: The validator compares screenshots before/after clicks.
At least 5% of viewport pixels (1920x1080 = ~100,000 pixels) must change for a click to be considered "responsive".

A small button changing color is NOT ENOUGH (a 100x40 button = 4000 pixels = 0.2% of viewport).

To pass validation, clicks MUST trigger LARGE visual changes:

1. OVERLAY/MODAL approach (recommended):
   - Click shows a full-screen or large overlay with feedback
   - Example: clicking an option shows a large "Selected!" overlay that covers 20%+ of screen

2. PANEL CHANGE approach:
   - Click changes an entire panel or section background
   - Example: clicking a filter highlights the entire sidebar or results area

3. RIPPLE/WAVE EFFECT approach:
   - Click triggers a CSS animation that expands across a large area
   - Example: a radial gradient animation that grows from click point

4. CONTENT SWAP approach:
   - Click replaces or transforms a large content area
   - Example: clicking "Next" animates the entire question panel

CSS Example that PASSES validation:
```css
.option:active, .option.selected {
    /* Small button change - NOT ENOUGH alone */
    background: #4CAF50;
}
.option.selected::after {
    /* Large overlay that PASSES validation */
    content: 'âœ“';
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(76, 175, 80, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 200px;
    animation: fadeOut 0.5s forwards;
}
```

JavaScript Example that PASSES validation:
```javascript
element.onclick = function() {
    // Change a LARGE area, not just this button
    document.querySelector('.main-panel').style.background = '#1a3a1a';
    // Or show large feedback
    showFullScreenFeedback('Selected!');
}
```

Output only the HTML code."""
