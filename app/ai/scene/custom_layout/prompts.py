"""
Custom Layout Prompts - HTML generation from content data.

Architecture:
=============
- Gemini = CONTENT (what to show, real data) - generated by backend
- Claude/Opus = DESIGN (how to show it) - full creative freedom

Sprint 6.1: Direct data flow without SceneGraph intermediate format.
"""

import json
from typing import Dict, Any, Optional


def build_data_to_html_prompt(
    content_data: Dict[str, Any],
    user_request: str,
    layout_hints: Optional[str] = None,
) -> str:
    """
    Build prompt for HTML generation from content data (no SceneGraph).

    This is the optimized flow where Gemini generates content data directly
    and Opus creates HTML without the SceneGraph intermediate format.

    Args:
        content_data: Content data from Gemini (type, title, data)
        user_request: Original user request
        layout_hints: Optional layout hints from intent parser

    Returns:
        Prompt string for Opus HTML generation
    """
    hints_section = ""
    if layout_hints:
        hints_section = f"\n## Layout Hints\n{layout_hints}\n"

    return f"""## Request
"{user_request}"
{hints_section}
## Content Data (use this exactly)
```json
{json.dumps(content_data, ensure_ascii=False, indent=2, default=str)}
```

## Output
Complete standalone HTML (<!DOCTYPE html> to </html>).
Target: 1920x1080 dark theme touchscreen display.
"""


def build_custom_layout_prompt(scene: Dict[str, Any], user_request: str = None) -> str:
    """
    Build prompt for Claude to generate custom HTML layout.

    Args:
        scene: SceneGraph with content data
        user_request: Original user request for context

    Returns:
        Prompt string
    """
    if not user_request:
        metadata = scene.get("metadata", {})
        user_request = metadata.get("user_request", "Display content")

    # Extract content from SceneGraph
    global_style = scene.get("global_style", {})
    layout = scene.get("layout", {})
    components = scene.get("components", [])
    animation_hints = scene.get("animation_hints", [])
    scroll_hints = scene.get("scroll_hints", [])

    # Build content summary
    content_data = {
        "user_request": user_request,
        "layout_intent": layout.get("intent", "fullscreen"),
        "style": {
            "background": global_style.get("background", "#0f0f23"),
            "text_color": global_style.get("text_color", "#ffffff"),
            "accent": global_style.get("accent_color", "#7b2cbf"),
        },
        "content": [
            {"type": comp.get("type"), "data": comp.get("data", {})}
            for comp in components
        ],
    }

    if animation_hints:
        content_data["animation_hints"] = animation_hints
    if scroll_hints:
        content_data["scroll_hints"] = scroll_hints

    prompt = f"""## Request
"{user_request}"

## Content (use this data, design freely)
```json
{json.dumps(content_data, ensure_ascii=False, indent=2, default=str)}
```

## Output
Complete standalone HTML (<!DOCTYPE html> to </html>).
Target: 1920x1080 dark theme display.
"""

    return prompt


def get_system_prompt() -> str:
    """System prompt for HTML generation."""
    return """You are an expert HTML/CSS/JS designer.

You receive CONTENT (what to display) and you CREATE the visual experience (how to display it).

The content data is your source material - use it to build something beautiful and engaging.
You have full creative freedom on design, layout, animations, and interactivity.

Use modern web features: CSS flexbox, grid, animations, :has(), scroll-snap.
Use JavaScript when needed for interactivity (quizzes, games, dynamic content).
Make it visually stunning and interactive.

Technical constraints:
- Standalone HTML with inline CSS/JS
- Target: 1920x1080 touchscreen

REQUIRED DATA ATTRIBUTES for interactive content (MUST use these for validation):

For TRIVIA/QUIZ:
- data-trivia="container" on main container
- data-question="N" on each question container (N = question number)
- data-option on each answer option/button
- data-submit on the submit/next button
- data-score on the score display element
- data-feedback on correct/incorrect feedback elements

For GAMES:
- data-game="container" on game container
- data-start on start/play button
- data-score on score display
- data-lives on lives/health display (if applicable)
- data-restart on restart/play-again button

For DASHBOARDS:
- data-dashboard="container" on main container
- data-filter on filter controls
- data-metric on KPI/metric displays
- data-chart on chart containers

INTERACTION REQUIREMENTS (for visual validation):

CRITICAL: The validator compares SCREENSHOTS before/after clicks.
At least 30% of the CLICKED ELEMENT must visually change.

## MANDATORY FOR ALL INTERACTIVE ELEMENTS:

Every clickable element MUST have a .selected or .active class with:
1. background-color change (MANDATORY - not optional)
2. Use CONCRETE colors: #ffffff, rgba(0,255,0,0.3), #00ff00
3. NEVER use var(--color) - CSS variables may not be defined

## PROHIBITED (will fail validation):
- filter: brightness() or opacity() alone - too subtle
- border-only without background change - not enough pixels
- var(--anything) - may not exist
- Subtle opacity changes (0.8 â†’ 1.0)

## GOOD EXAMPLES:
```css
.option.selected {
  background: rgba(0, 212, 255, 0.3);  /* MANDATORY */
  border: 3px solid #00d4ff;           /* optional addition */
  transform: scale(1.02);              /* optional addition */
}
```

## ALSO RECOMMENDED (for extra visibility):

1. PANEL CHANGE approach:
   - Click changes an entire panel or section background
   - Example: clicking a filter highlights the entire sidebar

2. OVERLAY approach:
   - Click shows a large overlay with feedback
   - Example: "Selected!" overlay covering 20%+ of screen

Output only the HTML code."""
