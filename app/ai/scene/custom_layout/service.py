"""
Custom Layout Service - Generate HTML layouts from SceneGraphs using GPT-5.2.

Sprint 5.2: This service takes a SceneGraph (generated by Claude) and sends it
to GPT-5.2 to create an enhanced, standalone HTML layout.

Architecture:
=============
- Uses existing openai_provider (DO NOT create new OpenAI client)
- Returns CustomLayoutResult with HTML and metadata
- Graceful error handling - returns None on failure (fallback to SceneGraph)

Usage:
======
    from app.ai.scene.custom_layout import custom_layout_service
    
    result = await custom_layout_service.generate_html(scene_dict, user_request)
    
    if result.success:
        html = result.html
    else:
        html = None  # Use SceneGraph fallback
"""

import logging
import time
from dataclasses import dataclass
from typing import Optional, Dict, Any

from app.ai.providers.openai_provider import openai_provider
from app.ai.providers.gemini import gemini_provider
from app.ai.scene.custom_layout.prompts import build_custom_layout_prompt, get_system_prompt
from app.ai.scene.custom_layout.html_repair_prompts import (
    build_html_diagnosis_prompt,
    build_html_repair_prompt,
    get_diagnosis_system_prompt,
    get_repair_system_prompt,
)
from app.core.config import settings


logger = logging.getLogger("jarvis.ai.scene.custom_layout")


# ---------------------------------------------------------------------------
# RESULT DATACLASS
# ---------------------------------------------------------------------------

@dataclass
class CustomLayoutResult:
    """
    Result of custom layout HTML generation.
    
    Attributes:
        html: Generated HTML string (None if generation failed)
        success: Whether generation was successful
        error: Error message if generation failed
        latency_ms: Time taken for generation in milliseconds
    """
    html: Optional[str]
    success: bool
    error: Optional[str]
    latency_ms: float


# ---------------------------------------------------------------------------
# CUSTOM LAYOUT SERVICE
# ---------------------------------------------------------------------------

class CustomLayoutService:
    """
    Service for generating custom HTML layouts from SceneGraphs.
    
    Uses GPT-5.2 via the existing openai_provider to generate
    standalone HTML that can be rendered directly on display devices.
    
    This service:
    - DOES NOT create new OpenAI clients (reuses openai_provider)
    - DOES NOT modify SceneGraph (read-only access)
    - DOES gracefully handle errors (returns failure result)
    """
    
    def __init__(self):
        """Initialize the custom layout service."""
        logger.info("Custom layout service initialized")
    
    async def generate_html(
        self,
        scene: Dict[str, Any],
        user_request: str,
        timeout_seconds: Optional[int] = None,
    ) -> CustomLayoutResult:
        """
        Generate custom HTML layout from a SceneGraph.
        
        Args:
            scene: SceneGraph dictionary (from Claude's scene generation)
            user_request: Original user request for context
            timeout_seconds: Optional timeout override (uses settings.CUSTOM_LAYOUT_TIMEOUT_SECONDS)
            
        Returns:
            CustomLayoutResult with HTML and generation metadata
        """
        start_time = time.time()
        
        # Check if feature is enabled
        if not getattr(settings, 'CUSTOM_LAYOUT_ENABLED', False):
            latency_ms = (time.time() - start_time) * 1000
            logger.debug("Custom layout feature is disabled")
            return CustomLayoutResult(
                html=None,
                success=False,
                error="Custom layout feature is disabled",
                latency_ms=latency_ms,
            )
        
        # Validate inputs
        if not scene:
            latency_ms = (time.time() - start_time) * 1000
            logger.warning("generate_html called with empty scene")
            return CustomLayoutResult(
                html=None,
                success=False,
                error="Empty scene provided",
                latency_ms=latency_ms,
            )
        
        try:
            # Build the prompt
            prompt = build_custom_layout_prompt(scene, user_request)
            system_prompt = get_system_prompt()
            
            logger.info(
                f"Generating custom HTML layout",
                extra={
                    "scene_id": scene.get("scene_id", "unknown"),
                    "component_count": len(scene.get("components", [])),
                    "layout_intent": scene.get("layout", {}).get("intent", "unknown"),
                }
            )
            
            # Call GPT-5.2 via existing openai_provider
            # Uses generate() for text response (HTML is text)
            response = await openai_provider.generate(
                prompt=prompt,
                system_prompt=system_prompt,
                temperature=0.3,  # Lower temperature for consistent output
                max_tokens=16384,  # HTML can be very verbose (flashcards, tables, etc.)
            )
            
            latency_ms = (time.time() - start_time) * 1000
            
            if not response.success:
                logger.error(f"GPT-5.2 HTML generation failed: {response.error}")
                return CustomLayoutResult(
                    html=None,
                    success=False,
                    error=response.error or "Unknown generation error",
                    latency_ms=latency_ms,
                )
            
            # Extract and clean HTML
            html = self._clean_html_response(response.content)
            
            if not html:
                logger.warning("GPT-5.2 returned empty or invalid HTML")
                return CustomLayoutResult(
                    html=None,
                    success=False,
                    error="Empty or invalid HTML response",
                    latency_ms=latency_ms,
                )
            
            # Basic validation - ensure it looks like HTML
            if not self._is_valid_html_structure(html):
                logger.warning("GPT-5.2 response doesn't look like valid HTML, attempting repair")
                
                # Sprint 5.2.1: Attempt intelligent HTML repair
                repaired_html = await self._repair_html_with_fallback(
                    invalid_html=html,
                    validation_error="Response is not valid HTML structure",
                    user_request=user_request,
                )
                
                if repaired_html:
                    logger.info("Using repaired HTML")
                    return CustomLayoutResult(
                        html=repaired_html,
                        success=True,
                        error=None,
                        latency_ms=(time.time() - start_time) * 1000,
                    )
                
                # Repair failed, return error
                return CustomLayoutResult(
                    html=None,
                    success=False,
                    error="Response is not valid HTML structure (repair failed)",
                    latency_ms=(time.time() - start_time) * 1000,
                )
            
            logger.info(
                f"Custom HTML layout generated successfully",
                extra={
                    "html_length": len(html),
                    "latency_ms": latency_ms,
                }
            )
            
            return CustomLayoutResult(
                html=html,
                success=True,
                error=None,
                latency_ms=latency_ms,
            )
            
        except Exception as e:
            latency_ms = (time.time() - start_time) * 1000
            logger.error(f"Custom layout generation error: {e}", exc_info=True)
            return CustomLayoutResult(
                html=None,
                success=False,
                error=str(e),
                latency_ms=latency_ms,
            )
    
    def _clean_html_response(self, content: str) -> Optional[str]:
        """
        Clean and extract HTML from GPT response.
        
        GPT might wrap HTML in markdown code blocks or add explanations.
        This method extracts just the HTML.
        
        Args:
            content: Raw response from GPT-5.2
            
        Returns:
            Cleaned HTML string or None if extraction fails
        """
        if not content:
            return None
        
        html = content.strip()
        
        # Remove markdown code blocks if present
        if html.startswith("```html"):
            html = html[7:]
        elif html.startswith("```"):
            html = html[3:]
        
        if html.endswith("```"):
            html = html[:-3]
        
        html = html.strip()
        
        # Ensure it starts with DOCTYPE or <html>
        lower_html = html.lower()
        if not (lower_html.startswith("<!doctype") or lower_html.startswith("<html")):
            # Try to find the start of HTML
            doctype_idx = lower_html.find("<!doctype")
            html_idx = lower_html.find("<html")
            
            if doctype_idx >= 0:
                html = html[doctype_idx:]
            elif html_idx >= 0:
                html = html[html_idx:]
            else:
                return None
        
        return html
    
    def _is_valid_html_structure(self, html: str) -> bool:
        """
        Basic validation that the string looks like valid HTML.
        
        This is a quick check, not a full HTML parser validation.
        Playwright validation is used for thorough checking.
        
        Args:
            html: HTML string to validate
            
        Returns:
            True if it appears to be valid HTML structure
        """
        if not html:
            return False
        
        lower_html = html.lower()
        
        # Must have html tags
        has_html_open = "<html" in lower_html
        has_html_close = "</html>" in lower_html
        
        # Must have body (or at least content)
        has_body = "<body" in lower_html or "<!doctype" in lower_html
        
        # Basic length check (HTML should have some content)
        is_reasonable_length = len(html) > 100
        
        return (has_html_open or has_body) and has_html_close and is_reasonable_length
    
    async def _repair_html_with_fallback(
        self,
        invalid_html: str,
        validation_error: str,
        user_request: str,
    ) -> Optional[str]:
        """
        Attempt to repair invalid HTML using Gemini diagnosis + GPT-5.2 repair.
        
        Sprint 5.2.1: When GPT-5.2 generates invalid HTML, this method:
        1. Uses Gemini (fast, cheap) to diagnose the issue
        2. Uses GPT-5.2 to repair based on the diagnosis
        3. Validates the repaired HTML
        
        Args:
            invalid_html: The HTML that failed validation
            validation_error: Why it failed
            user_request: Original user request for context
            
        Returns:
            Repaired HTML string or None if repair failed
        """
        # Check if repair is enabled
        if not getattr(settings, 'HTML_REPAIR_ENABLED', True):
            logger.debug("HTML repair is disabled")
            return None
        
        max_retries = getattr(settings, 'HTML_REPAIR_MAX_RETRIES', 1)
        
        for attempt in range(max_retries):
            try:
                logger.info(f"HTML repair attempt {attempt + 1}/{max_retries}")
                
                # Step 1: Gemini diagnoses the issue (fast, cheap)
                diagnosis_prompt = build_html_diagnosis_prompt(invalid_html, validation_error)
                diagnosis_response = await gemini_provider.generate(
                    prompt=diagnosis_prompt,
                    system_prompt=get_diagnosis_system_prompt(),
                    temperature=0.1,
                    max_tokens=256,
                )
                
                if not diagnosis_response.success:
                    logger.warning(f"Gemini diagnosis failed: {diagnosis_response.error}")
                    continue
                
                diagnosis = diagnosis_response.content.strip()
                logger.info(f"HTML diagnosis: {diagnosis}")
                
                # Step 2: GPT-5.2 repairs based on diagnosis
                repair_prompt = build_html_repair_prompt(
                    html=invalid_html,
                    diagnosis=diagnosis,
                    original_request=user_request,
                )
                repair_response = await openai_provider.generate(
                    prompt=repair_prompt,
                    system_prompt=get_repair_system_prompt(),
                    temperature=0.2,
                    max_tokens=16384,  # Match main generation limit
                )
                
                if not repair_response.success:
                    logger.warning(f"GPT-5.2 repair failed: {repair_response.error}")
                    continue
                
                # Step 3: Clean and validate repaired HTML
                repaired_html = self._clean_html_response(repair_response.content)
                
                if repaired_html and self._is_valid_html_structure(repaired_html):
                    logger.info(f"HTML repair successful on attempt {attempt + 1}")
                    return repaired_html
                else:
                    logger.warning(f"Repaired HTML still invalid on attempt {attempt + 1}")
                    # Update invalid_html for next attempt
                    if repaired_html:
                        invalid_html = repaired_html
                    
            except Exception as e:
                logger.error(f"HTML repair error on attempt {attempt + 1}: {e}", exc_info=True)
                continue
        
        logger.error(f"HTML repair failed after {max_retries} attempts")
        return None


# ---------------------------------------------------------------------------
# SINGLETON INSTANCE
# ---------------------------------------------------------------------------
custom_layout_service = CustomLayoutService()
