"""
Custom Layout Service - Generate HTML layouts from SceneGraphs using Opus 4.5.

Sprint 5.2.2: This service takes a SceneGraph (generated by Gemini) and sends it
to Opus 4.5 to create an enhanced, standalone HTML layout with CSS interactivity.

Sprint 7: Vision-Enhanced Repair
- Uses screenshots for visual coherence checking
- Detects invisible elements (exist in DOM but not rendered)
- Uses Sonnet's vision + extended thinking for complex repairs

Architecture:
=============
- Uses existing openai_provider (DO NOT create new OpenAI client)
- Returns CustomLayoutResult with HTML and metadata
- Graceful error handling - returns None on failure (fallback to SceneGraph)

Usage:
======
    from app.ai.scene.custom_layout import custom_layout_service

    result = await custom_layout_service.generate_html(scene_dict, user_request)

    if result.success:
        html = result.html
    else:
        html = None  # Use SceneGraph fallback
"""

import logging
import time
import os
from datetime import datetime
from dataclasses import dataclass
from typing import Optional, Dict, Any

from app.ai.providers.openai_provider import openai_provider, OpenAIProvider
from app.ai.providers.gemini import gemini_provider
from app.ai.providers.anthropic_provider import AnthropicProvider
from app.ai.scene.custom_layout.prompts import (
    build_custom_layout_prompt,
    build_data_to_html_prompt,
    get_system_prompt,
)
from app.ai.scene.custom_layout.html_repair_prompts import (
    build_html_diagnosis_prompt,
    build_html_repair_prompt,
    get_diagnosis_system_prompt,
    get_repair_system_prompt,
    build_css_debug_diagnosis_prompt,
    build_css_debug_repair_prompt,
    get_css_debug_diagnosis_system_prompt,
    get_css_debug_repair_system_prompt,
    build_validation_diagnosis_prompt,
    build_validation_repair_prompt,
    get_validation_diagnosis_system_prompt,
    get_validation_repair_system_prompt,
)
from app.ai.scene.custom_layout.validator import ValidationResult
from app.ai.scene.custom_layout.validation import (
    VisualValidator,
    ValidationContract,
    SandboxResult,
    visual_validator,
    direct_fixer,
)
from app.core.config import settings

# Opus 4.5 for HTML generation + Fixer for repairs (Sprint 6.1)
opus_provider = AnthropicProvider(model=settings.ANTHROPIC_REASONING_MODEL)


logger = logging.getLogger("jarvis.ai.scene.custom_layout")

# Directory to save generated HTML for debugging
# Use local path for development, /app/debug_html for production
import os as _os
HTML_DEBUG_DIR = _os.environ.get("HTML_DEBUG_DIR", "/tmp/jarvis_debug_html")


def save_html_for_debug(html: str, request_id: str = None, suffix: str = "") -> Optional[str]:
    """
    Save generated HTML to a file for manual inspection.

    Args:
        html: The HTML content to save
        request_id: Optional request ID for the filename
        suffix: Optional suffix (e.g., 'repaired', 'original')

    Returns:
        Path to saved file, or None if save failed
    """
    try:
        os.makedirs(HTML_DEBUG_DIR, exist_ok=True)

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        req_part = f"_{request_id[:8]}" if request_id else ""
        suffix_part = f"_{suffix}" if suffix else ""
        filename = f"layout_{timestamp}{req_part}{suffix_part}.html"
        filepath = os.path.join(HTML_DEBUG_DIR, filename)

        with open(filepath, "w", encoding="utf-8") as f:
            f.write(html)

        logger.info(f"HTML saved for debug: {filepath}")
        return filepath
    except Exception as e:
        logger.warning(f"Failed to save debug HTML: {e}")
        return None


# ---------------------------------------------------------------------------
# RESULT DATACLASS
# ---------------------------------------------------------------------------

@dataclass
class CustomLayoutResult:
    """
    Result of custom layout HTML generation.
    
    Attributes:
        html: Generated HTML string (None if generation failed)
        success: Whether generation was successful
        error: Error message if generation failed
        latency_ms: Time taken for generation in milliseconds
    """
    html: Optional[str]
    success: bool
    error: Optional[str]
    latency_ms: float


# ---------------------------------------------------------------------------
# CUSTOM LAYOUT SERVICE
# ---------------------------------------------------------------------------

class CustomLayoutService:
    """
    Service for generating custom HTML layouts from SceneGraphs.
    
    Uses GPT-5.2 via the existing openai_provider to generate
    standalone HTML that can be rendered directly on display devices.
    
    This service:
    - DOES NOT create new OpenAI clients (reuses openai_provider)
    - DOES NOT modify SceneGraph (read-only access)
    - DOES gracefully handle errors (returns failure result)
    """
    
    def __init__(self):
        """Initialize the custom layout service."""
        logger.info("Custom layout service initialized")
    
    async def generate_html(
        self,
        scene: Dict[str, Any],
        user_request: str,
        timeout_seconds: Optional[int] = None,
    ) -> CustomLayoutResult:
        """
        Generate custom HTML layout from a SceneGraph.
        
        Args:
            scene: SceneGraph dictionary (from Claude's scene generation)
            user_request: Original user request for context
            timeout_seconds: Optional timeout override (uses settings.CUSTOM_LAYOUT_TIMEOUT_SECONDS)
            
        Returns:
            CustomLayoutResult with HTML and generation metadata
        """
        start_time = time.time()
        
        # Check if feature is enabled
        if not getattr(settings, 'CUSTOM_LAYOUT_ENABLED', False):
            latency_ms = (time.time() - start_time) * 1000
            logger.debug("Custom layout feature is disabled")
            return CustomLayoutResult(
                html=None,
                success=False,
                error="Custom layout feature is disabled",
                latency_ms=latency_ms,
            )
        
        # Validate inputs
        if not scene:
            latency_ms = (time.time() - start_time) * 1000
            logger.warning("generate_html called with empty scene")
            return CustomLayoutResult(
                html=None,
                success=False,
                error="Empty scene provided",
                latency_ms=latency_ms,
            )
        
        try:
            # Build the prompt
            prompt = build_custom_layout_prompt(scene, user_request)
            system_prompt = get_system_prompt()
            
            logger.info(
                f"Generating custom HTML layout",
                extra={
                    "scene_id": scene.get("scene_id", "unknown"),
                    "component_count": len(scene.get("components", [])),
                    "layout_intent": scene.get("layout", {}).get("intent", "unknown"),
                }
            )
            
            # =========================================================
            # GPT-5.2 HTML Generation (Sprint 5.2)
            # Single pass - GPT-5.2 generates working CSS interactivity
            # =========================================================

            logger.info("Generating HTML layout with Opus 4.5")

            response = await opus_provider.generate(
                prompt=prompt,
                system_prompt=system_prompt,
                temperature=0.7,
                max_tokens=16384,
            )

            if not response.success:
                logger.error(f"Opus 4.5 generation failed: {response.error}")
                return CustomLayoutResult(
                    html=None,
                    success=False,
                    error=response.error or "HTML generation failed",
                    latency_ms=(time.time() - start_time) * 1000,
                )

            html = self._clean_html_response(response.content)
            logger.info(f"Opus 4.5 completed in {response.latency_ms:.0f}ms")

            latency_ms = (time.time() - start_time) * 1000

            if not html:
                logger.error(f"HTML generation failed: no valid HTML produced")
                return CustomLayoutResult(
                    html=None,
                    success=False,
                    error="No valid HTML produced",
                    latency_ms=latency_ms,
                )

            # Basic validation - ensure it looks like HTML
            if not self._is_valid_html_structure(html):
                logger.warning("HTML structure invalid, attempting repair")

                # Fallback: Attempt structural HTML repair
                repaired_html = await self._repair_html_with_fallback(
                    invalid_html=html,
                    validation_error="Response is not valid HTML structure",
                    user_request=user_request,
                )

                if repaired_html:
                    html = repaired_html
                    logger.info("Using structurally repaired HTML")
                else:
                    return CustomLayoutResult(
                        html=None,
                        success=False,
                        error="HTML structure invalid (repair failed)",
                        latency_ms=(time.time() - start_time) * 1000,
                    )
            
            logger.info(
                f"Custom HTML layout generated successfully",
                extra={
                    "html_length": len(html),
                    "latency_ms": latency_ms,
                }
            )

            # Save HTML for debugging/inspection
            save_html_for_debug(html, suffix="final")

            return CustomLayoutResult(
                html=html,
                success=True,
                error=None,
                latency_ms=latency_ms,
            )

        except Exception as e:
            latency_ms = (time.time() - start_time) * 1000
            logger.error(f"Custom layout generation error: {e}", exc_info=True)
            return CustomLayoutResult(
                html=None,
                success=False,
                error=str(e),
                latency_ms=latency_ms,
            )

    async def generate_html_from_data(
        self,
        content_data: Dict[str, Any],
        user_request: str,
        layout_hints: Optional[str] = None,
        layout_type: Optional[str] = None,
    ) -> CustomLayoutResult:
        """
        Generate HTML directly from content data (no SceneGraph).

        Sprint 6.1 Optimization: Skip SceneGraph intermediate format.
        Gemini generates content data → Opus creates HTML directly.

        This is ~10-15s faster than the SceneGraph flow.

        Args:
            content_data: Content data from Gemini (type, title, data)
            user_request: Original user request
            layout_hints: Optional layout hints string
            layout_type: Optional layout type (trivia, dashboard, etc.)

        Returns:
            CustomLayoutResult with generated HTML
        """
        start_time = time.time()

        # Check if feature is enabled
        if not getattr(settings, 'CUSTOM_LAYOUT_ENABLED', False):
            return CustomLayoutResult(
                html=None,
                success=False,
                error="Custom layout feature is disabled",
                latency_ms=(time.time() - start_time) * 1000,
            )

        if not content_data:
            return CustomLayoutResult(
                html=None,
                success=False,
                error="Empty content data provided",
                latency_ms=(time.time() - start_time) * 1000,
            )

        try:
            # Build prompt from content data (no SceneGraph)
            prompt = build_data_to_html_prompt(content_data, user_request, layout_hints)
            system_prompt = get_system_prompt()

            detected_type = layout_type or content_data.get("content_type", "unknown")

            logger.info(f"Generating HTML from data (type={detected_type})")

            # Generate with Opus 4.5
            response = await opus_provider.generate(
                prompt=prompt,
                system_prompt=system_prompt,
                temperature=0.7,
                max_tokens=16384,
            )

            if not response.success:
                logger.error(f"Opus generation failed: {response.error}")
                return CustomLayoutResult(
                    html=None,
                    success=False,
                    error=response.error or "HTML generation failed",
                    latency_ms=(time.time() - start_time) * 1000,
                )

            html = self._clean_html_response(response.content)
            logger.info(f"Opus completed in {response.latency_ms:.0f}ms")

            if not html or not self._is_valid_html_structure(html):
                logger.warning("Invalid HTML structure from direct generation")
                return CustomLayoutResult(
                    html=None,
                    success=False,
                    error="Invalid HTML structure",
                    latency_ms=(time.time() - start_time) * 1000,
                )

            # Save for debugging
            save_html_for_debug(html, suffix="from_data")

            return CustomLayoutResult(
                html=html,
                success=True,
                error=None,
                latency_ms=(time.time() - start_time) * 1000,
            )

        except Exception as e:
            logger.error(f"Direct HTML generation error: {e}", exc_info=True)
            return CustomLayoutResult(
                html=None,
                success=False,
                error=str(e),
                latency_ms=(time.time() - start_time) * 1000,
            )

    async def generate_and_validate_html_from_data(
        self,
        content_data: Dict[str, Any],
        user_request: str,
        layout_hints: Optional[str] = None,
        layout_type: Optional[str] = None,
    ) -> CustomLayoutResult:
        """
        Generate HTML from content data AND validate with visual validation.

        Sprint 6.1: Direct flow with visual validation.
        This combines the speed of direct data→HTML with the quality
        assurance of visual validation.

        Flow:
        1. Generate HTML from content_data with Opus
        2. Validate with VisualValidator (screenshot comparison)
        3. If fails, repair with DirectFixer (Sonnet 4.5)
        4. Re-validate repaired HTML
        5. Return result

        Args:
            content_data: Content data from Gemini
            user_request: Original user request
            layout_hints: Optional layout hints
            layout_type: Optional layout type hint

        Returns:
            CustomLayoutResult with validated HTML
        """
        start_time = time.time()

        # Step 1: Generate HTML from data
        result = await self.generate_html_from_data(
            content_data=content_data,
            user_request=user_request,
            layout_hints=layout_hints,
            layout_type=layout_type,
        )

        if not result.success or not result.html:
            return result

        # Check if visual validation is enabled
        use_visual_validation = getattr(settings, 'VISUAL_VALIDATION_ENABLED', True)

        if not use_visual_validation:
            logger.info("Visual validation disabled, returning generated HTML")
            return result

        html = result.html

        # Detect layout type
        detected_type = layout_type or content_data.get("content_type", "unknown")

        logger.info(f"Starting visual validation for direct flow (layout_type={detected_type})")

        # Step 2: Validate with VisualValidator
        contract = ValidationContract(
            html=html,
            layout_type=detected_type,
            visual_change_threshold=getattr(settings, 'VISUAL_CHANGE_THRESHOLD', 0.05),
            blank_page_threshold=getattr(settings, 'BLANK_PAGE_THRESHOLD', 0.95),
            max_inputs_to_test=getattr(settings, 'MAX_INPUTS_TO_TEST', 10),
            stabilization_ms=getattr(settings, 'INTERACTION_STABILIZATION_MS', 150),
        )

        validation_result = await visual_validator.validate(contract)

        if validation_result.valid:
            logger.info(
                f"Visual validation passed (direct flow) - "
                f"inputs={validation_result.inputs_responsive}/{validation_result.inputs_tested}, "
                f"confidence={validation_result.confidence:.2f}"
            )
            return CustomLayoutResult(
                html=html,
                success=True,
                error=None,
                latency_ms=(time.time() - start_time) * 1000,
            )

        # Step 3: Validation failed - attempt repair
        logger.warning(
            f"Visual validation failed (direct flow): {validation_result.failure_summary}"
        )

        max_repair_attempts = getattr(settings, 'VALIDATION_REPAIR_MAX_RETRIES', 2)

        # Sprint 7: Check if vision repair is enabled
        use_vision_repair = getattr(settings, 'VISION_REPAIR_ENABLED', True)

        for attempt in range(max_repair_attempts):
            logger.info(f"Visual repair attempt {attempt + 1}/{max_repair_attempts} (direct flow)")

            # Sprint 7: Use vision repair if screenshot is available
            if use_vision_repair and validation_result.page_screenshot:
                logger.info("Using vision-enhanced repair with screenshot")
                repaired_html = await direct_fixer.repair_with_vision(
                    html=html,
                    sandbox_result=validation_result,
                    user_request=user_request,
                    screenshot=validation_result.page_screenshot,
                )
            else:
                # Fallback to text-only repair
                repaired_html = await direct_fixer.repair(
                    html=html,
                    sandbox_result=validation_result,
                    user_request=user_request,
                )

            if not repaired_html:
                logger.warning(f"Repair attempt {attempt + 1} failed to produce HTML")
                continue

            # Save repaired HTML for debugging
            save_html_for_debug(repaired_html, suffix=f"direct_repaired_{attempt + 1}")

            # Step 4: Re-validate repaired HTML
            repair_contract = ValidationContract(
                html=repaired_html,
                layout_type=detected_type,
                visual_change_threshold=getattr(settings, 'VISUAL_CHANGE_THRESHOLD', 0.05),
                blank_page_threshold=getattr(settings, 'BLANK_PAGE_THRESHOLD', 0.95),
                max_inputs_to_test=getattr(settings, 'MAX_INPUTS_TO_TEST', 10),
                stabilization_ms=getattr(settings, 'INTERACTION_STABILIZATION_MS', 150),
            )

            repair_validation = await visual_validator.validate(repair_contract)

            if repair_validation.valid:
                logger.info(
                    f"Repair successful after {attempt + 1} attempts (direct flow) - "
                    f"inputs={repair_validation.inputs_responsive}/{repair_validation.inputs_tested}"
                )
                return CustomLayoutResult(
                    html=repaired_html,
                    success=True,
                    error=None,
                    latency_ms=(time.time() - start_time) * 1000,
                )

            # Update for next repair attempt
            html = repaired_html
            validation_result = repair_validation

        # All repair attempts failed - return best effort
        logger.warning(
            f"All repair attempts failed (direct flow). Returning last HTML. "
            f"Final: {validation_result.inputs_responsive}/{validation_result.inputs_tested} responsive"
        )

        return CustomLayoutResult(
            html=html,
            success=True,  # Return HTML anyway, let user see it
            error=f"Validation incomplete: {validation_result.failure_summary}",
            latency_ms=(time.time() - start_time) * 1000,
        )

    def _clean_html_response(self, content: str) -> Optional[str]:
        """
        Clean and extract HTML from GPT response.
        
        GPT might wrap HTML in markdown code blocks or add explanations.
        This method extracts just the HTML.
        
        Args:
            content: Raw response from GPT-5.2
            
        Returns:
            Cleaned HTML string or None if extraction fails
        """
        if not content:
            return None
        
        html = content.strip()
        
        # Remove markdown code blocks if present
        if html.startswith("```html"):
            html = html[7:]
        elif html.startswith("```"):
            html = html[3:]
        
        if html.endswith("```"):
            html = html[:-3]
        
        html = html.strip()
        
        # Ensure it starts with DOCTYPE or <html>
        lower_html = html.lower()
        if not (lower_html.startswith("<!doctype") or lower_html.startswith("<html")):
            # Try to find the start of HTML
            doctype_idx = lower_html.find("<!doctype")
            html_idx = lower_html.find("<html")
            
            if doctype_idx >= 0:
                html = html[doctype_idx:]
            elif html_idx >= 0:
                html = html[html_idx:]
            else:
                return None
        
        return html

    def _extract_interactions_comment(self, html: str) -> Optional[str]:
        """
        Extract the INTERACTIONS comment from HTML if present.

        Args:
            html: HTML string that may contain <!-- INTERACTIONS: ... -->

        Returns:
            The interactions description or None if not found
        """
        if not html:
            return None

        import re
        # Match <!-- INTERACTIONS: ... --> comment
        match = re.search(r'<!--\s*INTERACTIONS:\s*(.*?)\s*-->', html, re.DOTALL | re.IGNORECASE)
        if match:
            return match.group(1).strip()
        return None

    def _is_valid_html_structure(self, html: str) -> bool:
        """
        Basic validation that the string looks like valid HTML.
        
        This is a quick check, not a full HTML parser validation.
        Playwright validation is used for thorough checking.
        
        Args:
            html: HTML string to validate
            
        Returns:
            True if it appears to be valid HTML structure
        """
        if not html:
            return False
        
        lower_html = html.lower()
        
        # Must have html tags
        has_html_open = "<html" in lower_html
        has_html_close = "</html>" in lower_html
        
        # Must have body (or at least content)
        has_body = "<body" in lower_html or "<!doctype" in lower_html
        
        # Basic length check (HTML should have some content)
        is_reasonable_length = len(html) > 100
        
        return (has_html_open or has_body) and has_html_close and is_reasonable_length
    
    async def _repair_html_with_fallback(
        self,
        invalid_html: str,
        validation_error: str,
        user_request: str,
    ) -> Optional[str]:
        """
        Attempt to repair invalid HTML using Gemini diagnosis + Codex-Max repair.

        Sprint 5.2.1: When Codex-Max generates invalid HTML, this method:
        1. Uses Gemini (fast, cheap) to diagnose the issue
        2. Uses Codex-Max to repair based on the diagnosis
        3. Validates the repaired HTML
        
        Args:
            invalid_html: The HTML that failed validation
            validation_error: Why it failed
            user_request: Original user request for context
            
        Returns:
            Repaired HTML string or None if repair failed
        """
        # Check if repair is enabled
        if not getattr(settings, 'HTML_REPAIR_ENABLED', True):
            logger.debug("HTML repair is disabled")
            return None
        
        max_retries = getattr(settings, 'HTML_REPAIR_MAX_RETRIES', 1)
        
        for attempt in range(max_retries):
            try:
                logger.info(f"HTML repair attempt {attempt + 1}/{max_retries}")
                
                # Step 1: Gemini diagnoses the issue (fast, cheap)
                diagnosis_prompt = build_html_diagnosis_prompt(invalid_html, validation_error)
                diagnosis_response = await gemini_provider.generate(
                    prompt=diagnosis_prompt,
                    system_prompt=get_diagnosis_system_prompt(),
                    temperature=0.1,
                    max_tokens=256,
                )
                
                if not diagnosis_response.success:
                    logger.warning(f"Gemini diagnosis failed: {diagnosis_response.error}")
                    continue
                
                diagnosis = diagnosis_response.content.strip()
                logger.info(f"HTML diagnosis: {diagnosis}")
                
                # Step 2: Codex-Max repairs based on diagnosis
                repair_prompt = build_html_repair_prompt(
                    html=invalid_html,
                    diagnosis=diagnosis,
                    original_request=user_request,
                )
                repair_response = await openai_provider.generate(
                    prompt=repair_prompt,
                    system_prompt=get_repair_system_prompt(),
                    temperature=0.2,
                    max_tokens=16384,
                )
                
                if not repair_response.success:
                    logger.warning(f"Codex-Max repair failed: {repair_response.error}")
                    continue
                
                # Step 3: Clean and validate repaired HTML
                repaired_html = self._clean_html_response(repair_response.content)
                
                if repaired_html and self._is_valid_html_structure(repaired_html):
                    logger.info(f"HTML repair successful on attempt {attempt + 1}")
                    return repaired_html
                else:
                    logger.warning(f"Repaired HTML still invalid on attempt {attempt + 1}")
                    # Update invalid_html for next attempt
                    if repaired_html:
                        invalid_html = repaired_html
                    
            except Exception as e:
                logger.error(f"HTML repair error on attempt {attempt + 1}: {e}", exc_info=True)
                continue
        
        logger.error(f"HTML repair failed after {max_retries} attempts")
        return None

    async def _debug_css_interactivity(
        self,
        html: str,
    ) -> Optional[str]:
        """
        Debug and fix CSS interactivity issues in generated HTML.

        Sprint 5.2.2: Two-pass approach - always runs after generation.
        Uses Gemini for diagnosis (fast) and Codex-Max for repair.

        Args:
            html: The HTML from Pass 1 (Codex-Max generation)

        Returns:
            Debugged HTML or original if no issues found
        """
        if not html:
            return None

        logger.info("Pass 2: Debugging CSS interactivity")

        # Extract expected interactions from HTML comment (if present)
        expected_interactions = self._extract_interactions_comment(html)
        if expected_interactions:
            logger.info(f"Expected interactions: {expected_interactions[:100]}...")

        try:
            # Step 1: Gemini diagnoses CSS interactivity issues (fast, cheap)
            diagnosis_prompt = build_css_debug_diagnosis_prompt(html, expected_interactions)
            diagnosis_response = await gemini_provider.generate(
                prompt=diagnosis_prompt,
                system_prompt=get_css_debug_diagnosis_system_prompt(),
                temperature=0.1,
                max_tokens=256,
            )

            if not diagnosis_response.success:
                logger.warning(f"CSS diagnosis failed: {diagnosis_response.error}")
                return html  # Return original if diagnosis fails

            diagnosis = diagnosis_response.content.strip()
            logger.info(f"CSS diagnosis: {diagnosis}")

            # If no issues found, return original HTML
            if "NO ISSUES" in diagnosis.upper():
                logger.info("Pass 2: No CSS interactivity issues found")
                return html

            # Step 2: Codex-Max fixes the issues
            logger.info("Pass 2: Fixing CSS interactivity bugs with Codex-Max")
            repair_prompt = build_css_debug_repair_prompt(html, diagnosis)

            repair_response = await openai_provider.generate_with_reasoning(
                prompt=repair_prompt,
                system_prompt=get_css_debug_repair_system_prompt(),
                effort="high",
                max_tokens=16384,
            )

            if not repair_response.success:
                logger.warning(f"CSS repair failed: {repair_response.error}")
                return html  # Return original if repair fails

            repaired_html = self._clean_html_response(repair_response.content)
            logger.info(f"Pass 2 completed in {repair_response.latency_ms:.0f}ms")

            return repaired_html if repaired_html else html

        except Exception as e:
            logger.error(f"CSS debug error: {e}", exc_info=True)
            return html  # Return original on any error

    async def repair_validation_errors(
        self,
        html: str,
        validation_result: ValidationResult,
        user_request: str,
    ) -> Optional[str]:
        """
        Repair HTML that failed Playwright validation.

        Sprint 5.3: When layout_validator.validate() fails, this method:
        1. Uses Gemini (fast) to diagnose the validation errors
        2. Uses GPT Codex-Max to repair based on the diagnosis
        3. Returns repaired HTML or None if repair failed

        Args:
            html: The HTML that failed validation
            validation_result: ValidationResult with errors and behavior_report
            user_request: Original user request for context

        Returns:
            Repaired HTML string or None if repair failed
        """
        if not getattr(settings, 'HTML_REPAIR_ENABLED', True):
            logger.debug("HTML repair is disabled")
            return None

        max_retries = getattr(settings, 'VALIDATION_REPAIR_MAX_RETRIES', 2)

        # Prepare behavior report string if available
        behavior_report_str = None
        if validation_result.behavior_report and validation_result.behavior_report.phase_executed:
            behavior_report_str = validation_result.behavior_report.to_diagnosis_string()

        current_html = html

        for attempt in range(max_retries):
            try:
                logger.info(f"Validation repair attempt {attempt + 1}/{max_retries}")

                # Step 1: Gemini diagnoses the validation errors (fast, cheap)
                diagnosis_prompt = build_validation_diagnosis_prompt(
                    html=current_html,
                    validation_errors=validation_result.errors,
                    behavior_report_str=behavior_report_str,
                )

                diagnosis_response = await gemini_provider.generate(
                    prompt=diagnosis_prompt,
                    system_prompt=get_validation_diagnosis_system_prompt(),
                    temperature=0.1,
                    max_tokens=512,
                )

                if not diagnosis_response.success:
                    logger.warning(f"Gemini diagnosis failed: {diagnosis_response.error}")
                    continue

                diagnosis = diagnosis_response.content.strip()
                logger.info(f"Validation diagnosis: {diagnosis}")

                # Step 2: GPT Codex-Max repairs based on diagnosis
                repair_prompt = build_validation_repair_prompt(
                    html=current_html,
                    diagnosis=diagnosis,
                    validation_errors=validation_result.errors,
                    user_request=user_request,
                )

                repair_response = await openai_provider.generate(
                    prompt=repair_prompt,
                    system_prompt=get_validation_repair_system_prompt(),
                    temperature=0.2,
                    max_tokens=16384,
                )

                if not repair_response.success:
                    logger.warning(f"Codex-Max repair failed: {repair_response.error}")
                    continue

                # Step 3: Clean and validate repaired HTML
                repaired_html = self._clean_html_response(repair_response.content)

                if repaired_html and self._is_valid_html_structure(repaired_html):
                    logger.info(f"Validation repair produced valid HTML on attempt {attempt + 1}")
                    return repaired_html
                else:
                    logger.warning(f"Repaired HTML still invalid structure on attempt {attempt + 1}")
                    if repaired_html:
                        current_html = repaired_html

            except Exception as e:
                logger.error(f"Validation repair error on attempt {attempt + 1}: {e}", exc_info=True)
                continue

        logger.error(f"Validation repair failed after {max_retries} attempts")
        return None

    async def generate_and_validate_html(
        self,
        scene: Dict[str, Any],
        user_request: str,
        layout_type: Optional[str] = None,
    ) -> CustomLayoutResult:
        """
        Generate HTML and validate with visual validation pipeline.

        Sprint 6: Uses the new 7-phase visual validation system that
        compares screenshots before/after clicks to detect real changes.

        Flow:
        1. Generate HTML with Opus 4.5
        2. Validate with VisualValidator (screenshot comparison)
        3. If fails, repair with DirectFixer (Codex-Max)
        4. Re-validate repaired HTML
        5. Return result

        Args:
            scene: SceneGraph dictionary
            user_request: Original user request
            layout_type: Optional layout type hint (trivia, dashboard, etc.)

        Returns:
            CustomLayoutResult with validated HTML
        """
        start_time = time.time()

        # Check if visual validation is enabled
        use_visual_validation = getattr(settings, 'VISUAL_VALIDATION_ENABLED', True)

        # Step 1: Generate HTML
        result = await self.generate_html(scene, user_request)

        if not result.success or not result.html:
            return result

        if not use_visual_validation:
            logger.info("Visual validation disabled, returning generated HTML")
            return result

        html = result.html

        # Detect layout type from scene if not provided
        if not layout_type:
            layout_type = self._detect_layout_type_from_scene(scene)

        logger.info(f"Starting visual validation (layout_type={layout_type})")

        # Step 2: Validate with VisualValidator
        contract = ValidationContract(
            html=html,
            layout_type=layout_type,
            visual_change_threshold=getattr(settings, 'VISUAL_CHANGE_THRESHOLD', 0.02),
            blank_page_threshold=getattr(settings, 'BLANK_PAGE_THRESHOLD', 0.95),
            max_inputs_to_test=getattr(settings, 'MAX_INPUTS_TO_TEST', 10),
            stabilization_ms=getattr(settings, 'INTERACTION_STABILIZATION_MS', 300),
        )

        validation_result = await visual_validator.validate(contract)

        if validation_result.valid:
            logger.info(
                f"Visual validation passed - "
                f"inputs={validation_result.inputs_responsive}/{validation_result.inputs_tested}, "
                f"confidence={validation_result.confidence:.2f}"
            )
            return CustomLayoutResult(
                html=html,
                success=True,
                error=None,
                latency_ms=(time.time() - start_time) * 1000,
            )

        # Step 3: Validation failed - attempt repair
        logger.warning(
            f"Visual validation failed: {validation_result.failure_summary}"
        )

        max_repair_attempts = getattr(settings, 'VALIDATION_REPAIR_MAX_RETRIES', 2)

        # Sprint 7: Check if vision repair is enabled
        use_vision_repair = getattr(settings, 'VISION_REPAIR_ENABLED', True)

        for attempt in range(max_repair_attempts):
            logger.info(f"Visual repair attempt {attempt + 1}/{max_repair_attempts}")

            # Sprint 7: Use vision repair if screenshot is available
            if use_vision_repair and validation_result.page_screenshot:
                logger.info("Using vision-enhanced repair with screenshot")
                repaired_html = await direct_fixer.repair_with_vision(
                    html=html,
                    sandbox_result=validation_result,
                    user_request=user_request,
                    screenshot=validation_result.page_screenshot,
                )
            else:
                # Fallback to text-only repair (Sonnet 4.5)
                repaired_html = await direct_fixer.repair(
                    html=html,
                    sandbox_result=validation_result,
                    user_request=user_request,
                )

            if not repaired_html:
                logger.warning(f"Repair attempt {attempt + 1} failed to produce HTML")
                continue

            # Save repaired HTML for debugging
            save_html_for_debug(repaired_html, suffix=f"repaired_{attempt + 1}")

            # Re-validate repaired HTML
            repair_contract = ValidationContract(
                html=repaired_html,
                layout_type=layout_type,
                visual_change_threshold=contract.visual_change_threshold,
                blank_page_threshold=contract.blank_page_threshold,
                max_inputs_to_test=contract.max_inputs_to_test,
                stabilization_ms=contract.stabilization_ms,
            )

            repair_validation = await visual_validator.validate(repair_contract)

            if repair_validation.valid:
                logger.info(
                    f"Repair successful on attempt {attempt + 1} - "
                    f"inputs={repair_validation.inputs_responsive}/{repair_validation.inputs_tested}"
                )
                return CustomLayoutResult(
                    html=repaired_html,
                    success=True,
                    error=None,
                    latency_ms=(time.time() - start_time) * 1000,
                )

            # Update for next attempt
            html = repaired_html
            validation_result = repair_validation
            logger.warning(
                f"Repaired HTML still failed validation: {repair_validation.failure_summary}"
            )

        # All repair attempts failed
        logger.error(
            f"Visual validation failed after {max_repair_attempts} repair attempts"
        )

        return CustomLayoutResult(
            html=None,
            success=False,
            error=f"Visual validation failed: {validation_result.failure_summary}",
            latency_ms=(time.time() - start_time) * 1000,
        )

    def _detect_layout_type_from_scene(self, scene: Dict[str, Any]) -> str:
        """
        Detect layout type from SceneGraph.

        Args:
            scene: SceneGraph dictionary

        Returns:
            Layout type string
        """
        # Check layout intent
        layout = scene.get("layout", {})
        intent = layout.get("intent", "").lower()

        if intent in ("trivia", "quiz"):
            return "trivia"
        elif intent in ("game", "mini_game"):
            return "mini_game"
        elif intent in ("dashboard",):
            return "dashboard"

        # Check components for hints
        components = scene.get("components", [])
        for comp in components:
            comp_type = comp.get("type", "").lower()
            if "trivia" in comp_type or "quiz" in comp_type:
                return "trivia"
            elif "game" in comp_type:
                return "mini_game"
            elif "chart" in comp_type or "metric" in comp_type:
                return "dashboard"

        return "unknown"


# ---------------------------------------------------------------------------
# SINGLETON INSTANCE
# ---------------------------------------------------------------------------
custom_layout_service = CustomLayoutService()
