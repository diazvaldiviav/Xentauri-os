"""
Custom Layout Service - Generate HTML layouts from SceneGraphs using Opus 4.5.

Sprint 5.2.2: This service takes a SceneGraph (generated by Gemini) and sends it
to Opus 4.5 to create an enhanced, standalone HTML layout with CSS interactivity.

Sprint 7: Vision-Enhanced Repair
- Uses screenshots for visual coherence checking
- Detects invisible elements (exist in DOM but not rendered)
- Uses Sonnet's vision + extended thinking for complex repairs

Architecture:
=============
- Uses existing openai_provider (DO NOT create new OpenAI client)
- Returns CustomLayoutResult with HTML and metadata
- Graceful error handling - returns None on failure (fallback to SceneGraph)

Usage:
======
    from app.ai.scene.custom_layout import custom_layout_service

    result = await custom_layout_service.generate_html(scene_dict, user_request)

    if result.success:
        html = result.html
    else:
        html = None  # Use SceneGraph fallback
"""

import logging
import time
import os
import uuid
from datetime import datetime
from dataclasses import dataclass
from typing import Optional, Dict, Any

from app.ai.providers.gemini import gemini_provider
from app.ai.providers.anthropic_provider import AnthropicProvider
from app.ai.scene.custom_layout.conversation_logger import (
    start_conversation,
    get_current_conversation,
    end_conversation,
)
from app.ai.scene.custom_layout.prompts import (
    build_custom_layout_prompt,
    build_data_to_html_prompt,
    get_system_prompt,
)
from app.ai.scene.custom_layout.html_repair_prompts import (
    build_html_diagnosis_prompt,
    build_html_repair_prompt,
    get_diagnosis_system_prompt,
    get_repair_system_prompt,
    build_css_debug_diagnosis_prompt,
    build_css_debug_repair_prompt,
    get_css_debug_diagnosis_system_prompt,
    get_css_debug_repair_system_prompt,
    build_validation_diagnosis_prompt,
    build_validation_repair_prompt,
    get_validation_diagnosis_system_prompt,
    get_validation_repair_system_prompt,
)
from app.ai.scene.custom_layout.validator import ValidationResult
from app.ai.scene.custom_layout.validation import (
    VisualValidator,
    ValidationContract,
    SandboxResult,
    FailedRepairAttempt,
    PipelineContext,  # Sprint 11: Accumulated context
    visual_validator,
    visual_analyzer,  # Sprint 11: For concordance check
    direct_fixer,
)
from app.ai.scene.custom_layout.validation.fixer import extract_state_css_rules
from app.core.config import settings

# Sprint 11: Opus 4.5 now used ONLY for repairs (fixer)
# HTML generation moved to Gemini Flash for speed/cost optimization
opus_provider = AnthropicProvider(model=settings.ANTHROPIC_REASONING_MODEL)


logger = logging.getLogger("jarvis.ai.scene.custom_layout")

# Directory to save generated HTML for debugging
# Use local path for development, /app/debug_html for production
import os as _os
HTML_DEBUG_DIR = _os.environ.get("HTML_DEBUG_DIR", "/tmp/jarvis_debug_html")


def save_html_for_debug(html: str, request_id: str = None, suffix: str = "") -> Optional[str]:
    """
    Save generated HTML to a file for manual inspection.

    Args:
        html: The HTML content to save
        request_id: Optional request ID for the filename
        suffix: Optional suffix (e.g., 'repaired', 'original')

    Returns:
        Path to saved file, or None if save failed
    """
    try:
        os.makedirs(HTML_DEBUG_DIR, exist_ok=True)

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        req_part = f"_{request_id[:8]}" if request_id else ""
        suffix_part = f"_{suffix}" if suffix else ""
        filename = f"layout_{timestamp}{req_part}{suffix_part}.html"
        filepath = os.path.join(HTML_DEBUG_DIR, filename)

        with open(filepath, "w", encoding="utf-8") as f:
            f.write(html)

        logger.info(f"HTML saved for debug: {filepath}")
        return filepath
    except Exception as e:
        logger.warning(f"Failed to save debug HTML: {e}")
        return None


# ---------------------------------------------------------------------------
# RESULT DATACLASS
# ---------------------------------------------------------------------------

@dataclass
class CustomLayoutResult:
    """
    Result of custom layout HTML generation.
    
    Attributes:
        html: Generated HTML string (None if generation failed)
        success: Whether generation was successful
        error: Error message if generation failed
        latency_ms: Time taken for generation in milliseconds
    """
    html: Optional[str]
    success: bool
    error: Optional[str]
    latency_ms: float


# ---------------------------------------------------------------------------
# CUSTOM LAYOUT SERVICE
# ---------------------------------------------------------------------------

class CustomLayoutService:
    """
    Service for generating custom HTML layouts from SceneGraphs.
    
    Uses GPT-5.2 via the existing openai_provider to generate
    standalone HTML that can be rendered directly on display devices.
    
    This service:
    - DOES NOT create new OpenAI clients (reuses openai_provider)
    - DOES NOT modify SceneGraph (read-only access)
    - DOES gracefully handle errors (returns failure result)
    """
    
    def __init__(self):
        """Initialize the custom layout service."""
        logger.info("Custom layout service initialized")
    
    async def generate_html(
        self,
        scene: Dict[str, Any],
        user_request: str,
        timeout_seconds: Optional[int] = None,
    ) -> CustomLayoutResult:
        """
        Generate custom HTML layout from a SceneGraph.
        
        Args:
            scene: SceneGraph dictionary (from Claude's scene generation)
            user_request: Original user request for context
            timeout_seconds: Optional timeout override (uses settings.CUSTOM_LAYOUT_TIMEOUT_SECONDS)
            
        Returns:
            CustomLayoutResult with HTML and generation metadata
        """
        start_time = time.time()
        
        # Check if feature is enabled
        if not getattr(settings, 'CUSTOM_LAYOUT_ENABLED', False):
            latency_ms = (time.time() - start_time) * 1000
            logger.debug("Custom layout feature is disabled")
            return CustomLayoutResult(
                html=None,
                success=False,
                error="Custom layout feature is disabled",
                latency_ms=latency_ms,
            )
        
        # Validate inputs
        if not scene:
            latency_ms = (time.time() - start_time) * 1000
            logger.warning("generate_html called with empty scene")
            return CustomLayoutResult(
                html=None,
                success=False,
                error="Empty scene provided",
                latency_ms=latency_ms,
            )
        
        try:
            # Build the prompt
            prompt = build_custom_layout_prompt(scene, user_request)
            system_prompt = get_system_prompt()
            
            logger.info(
                f"Generating custom HTML layout",
                extra={
                    "scene_id": scene.get("scene_id", "unknown"),
                    "component_count": len(scene.get("components", [])),
                    "layout_intent": scene.get("layout", {}).get("intent", "unknown"),
                }
            )
            
            # =========================================================
            # Sprint 11: Gemini Flash HTML Generation (NO thinking)
            # Fast/cheap generation, Opus reserved for repairs
            # =========================================================

            logger.info("Generating HTML layout with Gemini Flash (no thinking)")

            response = await gemini_provider.generate(
                prompt=prompt,
                system_prompt=system_prompt,
                temperature=0.7,
                max_tokens=16384,
                model_override=settings.GEMINI_REASONING_MODEL,  # Flash 3
                use_thinking=False,  # NO thinking for generation
            )

            if not response.success:
                logger.error(f"Flash generation failed: {response.error}")
                return CustomLayoutResult(
                    html=None,
                    success=False,
                    error=response.error or "HTML generation failed",
                    latency_ms=(time.time() - start_time) * 1000,
                )

            html = self._clean_html_response(response.content)
            logger.info(f"Flash completed in {response.latency_ms:.0f}ms")

            latency_ms = (time.time() - start_time) * 1000

            if not html:
                logger.error(f"HTML generation failed: no valid HTML produced")
                return CustomLayoutResult(
                    html=None,
                    success=False,
                    error="No valid HTML produced",
                    latency_ms=latency_ms,
                )

            # Basic validation - ensure it looks like HTML
            if not self._is_valid_html_structure(html):
                logger.warning("HTML structure invalid, attempting repair")

                # Fallback: Attempt structural HTML repair
                repaired_html = await self._repair_html_with_fallback(
                    invalid_html=html,
                    validation_error="Response is not valid HTML structure",
                    user_request=user_request,
                )

                if repaired_html:
                    html = repaired_html
                    logger.info("Using structurally repaired HTML")
                else:
                    return CustomLayoutResult(
                        html=None,
                        success=False,
                        error="HTML structure invalid (repair failed)",
                        latency_ms=(time.time() - start_time) * 1000,
                    )
            
            logger.info(
                f"Custom HTML layout generated successfully",
                extra={
                    "html_length": len(html),
                    "latency_ms": latency_ms,
                }
            )

            # Save HTML for debugging/inspection
            save_html_for_debug(html, suffix="final")

            return CustomLayoutResult(
                html=html,
                success=True,
                error=None,
                latency_ms=latency_ms,
            )

        except Exception as e:
            latency_ms = (time.time() - start_time) * 1000
            logger.error(f"Custom layout generation error: {e}", exc_info=True)
            return CustomLayoutResult(
                html=None,
                success=False,
                error=str(e),
                latency_ms=latency_ms,
            )

    async def generate_html_from_data(
        self,
        content_data: Dict[str, Any],
        user_request: str,
        layout_hints: Optional[str] = None,
        layout_type: Optional[str] = None,
    ) -> CustomLayoutResult:
        """
        Generate HTML directly from content data (no SceneGraph).

        Sprint 6.1 Optimization: Skip SceneGraph intermediate format.
        Gemini generates content data → Opus creates HTML directly.

        This is ~10-15s faster than the SceneGraph flow.

        Args:
            content_data: Content data from Gemini (type, title, data)
            user_request: Original user request
            layout_hints: Optional layout hints string
            layout_type: Optional layout type (trivia, dashboard, etc.)

        Returns:
            CustomLayoutResult with generated HTML
        """
        start_time = time.time()

        # Check if feature is enabled
        if not getattr(settings, 'CUSTOM_LAYOUT_ENABLED', False):
            return CustomLayoutResult(
                html=None,
                success=False,
                error="Custom layout feature is disabled",
                latency_ms=(time.time() - start_time) * 1000,
            )

        if not content_data:
            return CustomLayoutResult(
                html=None,
                success=False,
                error="Empty content data provided",
                latency_ms=(time.time() - start_time) * 1000,
            )

        try:
            # Build prompt from content data (no SceneGraph)
            prompt = build_data_to_html_prompt(content_data, user_request, layout_hints)
            system_prompt = get_system_prompt()

            detected_type = layout_type or content_data.get("content_type", "unknown")

            logger.info(f"Generating HTML from data (type={detected_type})")

            # Start conversation logging
            request_id = str(uuid.uuid4())
            conv = start_conversation(request_id, user_request)

            # Sprint 11: Generate with Gemini Flash (NO thinking) - fast/cheap
            # Opus moved to fixer role only
            logger.info("Generating HTML with Gemini Flash (no thinking)")

            response = await gemini_provider.generate(
                prompt=prompt,
                system_prompt=system_prompt,
                temperature=0.7,
                max_tokens=16384,
                model_override=settings.GEMINI_REASONING_MODEL,  # Flash 3
                use_thinking=False,  # NO thinking for generation
            )

            # Log Flash HTML generation response
            conv.log_flash_html_response(
                response.content if response.content else "ERROR: No content",
                response.latency_ms,
                response.usage.total_tokens if response.usage else 0
            )

            if not response.success:
                logger.error(f"Flash generation failed: {response.error}")
                conv.log_error(f"Flash failed: {response.error}")
                return CustomLayoutResult(
                    html=None,
                    success=False,
                    error=response.error or "HTML generation failed",
                    latency_ms=(time.time() - start_time) * 1000,
                )

            html = self._clean_html_response(response.content)
            logger.info(f"Flash completed in {response.latency_ms:.0f}ms")

            if not html or not self._is_valid_html_structure(html):
                logger.warning("Invalid HTML structure from direct generation")
                return CustomLayoutResult(
                    html=None,
                    success=False,
                    error="Invalid HTML structure",
                    latency_ms=(time.time() - start_time) * 1000,
                )

            # Save for debugging
            save_html_for_debug(html, suffix="from_data")

            return CustomLayoutResult(
                html=html,
                success=True,
                error=None,
                latency_ms=(time.time() - start_time) * 1000,
            )

        except Exception as e:
            logger.error(f"Direct HTML generation error: {e}", exc_info=True)
            return CustomLayoutResult(
                html=None,
                success=False,
                error=str(e),
                latency_ms=(time.time() - start_time) * 1000,
            )

    async def generate_and_validate_html_from_data(
        self,
        content_data: Dict[str, Any],
        user_request: str,
        layout_hints: Optional[str] = None,
        layout_type: Optional[str] = None,
    ) -> CustomLayoutResult:
        """
        Generate HTML from content data AND validate with visual validation.

        Sprint 6.1: Direct flow with visual validation.
        This combines the speed of direct data→HTML with the quality
        assurance of visual validation.

        Flow:
        1. Generate HTML from content_data with Opus
        2. Validate with VisualValidator (screenshot comparison)
        3. If fails, repair with DirectFixer (Sonnet 4.5)
        4. Re-validate repaired HTML
        5. Return result

        Args:
            content_data: Content data from Gemini
            user_request: Original user request
            layout_hints: Optional layout hints
            layout_type: Optional layout type hint

        Returns:
            CustomLayoutResult with validated HTML
        """
        start_time = time.time()

        # Step 1: Generate HTML from data
        result = await self.generate_html_from_data(
            content_data=content_data,
            user_request=user_request,
            layout_hints=layout_hints,
            layout_type=layout_type,
        )

        if not result.success or not result.html:
            return result

        # Check if visual validation is enabled
        use_visual_validation = getattr(settings, 'VISUAL_VALIDATION_ENABLED', True)

        if not use_visual_validation:
            logger.info("Visual validation disabled, returning generated HTML")
            return result

        html = result.html

        # Detect layout type
        detected_type = layout_type or content_data.get("content_type", "unknown")

        logger.info(f"Starting visual validation for direct flow (layout_type={detected_type})")

        # Step 2: Validate with VisualValidator
        contract = ValidationContract(
            html=html,
            layout_type=detected_type,
            visual_change_threshold=getattr(settings, 'VISUAL_CHANGE_THRESHOLD', 0.05),
            blank_page_threshold=getattr(settings, 'BLANK_PAGE_THRESHOLD', 0.95),
            max_inputs_to_test=getattr(settings, 'MAX_INPUTS_TO_TEST', 10),
            stabilization_ms=getattr(settings, 'INTERACTION_STABILIZATION_MS', 150),
        )

        validation_result = await visual_validator.validate(contract)

        # =====================================================================
        # Sprint 11: FULL PIPELINE with ACCUMULATED CONTEXT
        # All 3 models work as ONE - each step builds on previous context
        # =====================================================================

        # Create PipelineContext - this is the "shared memory"
        pipeline_ctx = PipelineContext(
            user_request=user_request,
            content_data=content_data,
            generated_html=html,
            generation_model="gemini-3-flash",
            generation_latency_ms=result.latency_ms,
            validation_result=validation_result,
        )

        # Step 2: Visual Concordance Check (Flash NO thinking)
        conv = get_current_conversation()
        if validation_result.page_screenshot:
            logger.info("Sprint 11 Step 2: Visual concordance check (Flash NO thinking)")

            # Log concordance prompt
            concordance_prompt = f"Compare screenshot to user request: {user_request}"
            if conv:
                conv.log_flash_concordance_prompt(concordance_prompt, has_screenshot=True)

            import time as _time
            concordance_start = _time.time()

            concordance_passed, concordance_diagnosis, concordance_confidence = \
                await visual_analyzer.check_visual_concordance(
                    screenshot_bytes=validation_result.page_screenshot,
                    user_request=user_request,
                )

            concordance_latency = (_time.time() - concordance_start) * 1000

            # Log concordance response
            if conv:
                conv.log_flash_concordance_response(
                    response=concordance_diagnosis,
                    passed=concordance_passed,
                    confidence=concordance_confidence,
                    latency_ms=concordance_latency,
                )

            # ACCUMULATE in context
            pipeline_ctx.concordance_passed = concordance_passed
            pipeline_ctx.concordance_diagnosis = concordance_diagnosis
            pipeline_ctx.concordance_confidence = concordance_confidence
            pipeline_ctx.screenshot_bytes = validation_result.page_screenshot

            # Also store in validation_result for backward compatibility
            validation_result.concordance_diagnosis = concordance_diagnosis

            if concordance_passed:
                logger.info(
                    f"Visual concordance PASSED: {concordance_diagnosis} "
                    f"(confidence={concordance_confidence:.2f})"
                )
            else:
                logger.warning(
                    f"Visual concordance FAILED: {concordance_diagnosis} "
                    f"(confidence={concordance_confidence:.2f})"
                )

        # Step 3 & 4: Technical Diagnosis (Flash WITH thinking) + Opus Repair
        # Pass FULL CONTEXT so models work as ONE
        logger.info("Sprint 11 Step 3-4: Flash diagnosis + Opus repair (with FULL CONTEXT)")

        if validation_result.page_screenshot:
            # Full pipeline with vision AND accumulated context
            final_html = await direct_fixer.repair_with_vision(
                html=html,
                sandbox_result=validation_result,
                user_request=user_request,
                screenshot=validation_result.page_screenshot,
                failed_attempts=[],
                pipeline_context=pipeline_ctx,  # Sprint 11: Pass full context
            )
        else:
            # Fallback to text-only repair (no screenshot available)
            logger.warning("No screenshot available, using text-only repair")
            final_html = await direct_fixer.repair(
                html=html,
                sandbox_result=validation_result,
                user_request=user_request,
                failed_attempts=[],
                pipeline_context=pipeline_ctx,  # Sprint 11: Pass full context
            )

        # Update context with final result
        pipeline_ctx.repaired_html = final_html

        # Return result - use Opus output if available, otherwise original
        if final_html:
            save_html_for_debug(final_html, suffix="sprint11_final")
            logger.info(
                f"Sprint 11 pipeline complete - "
                f"concordance={'PASS' if pipeline_ctx.concordance_passed else 'FAIL'}, "
                f"original_len={len(html)}, final_len={len(final_html)}"
            )
            return CustomLayoutResult(
                html=final_html,
                success=True,
                error=None,
                latency_ms=(time.time() - start_time) * 1000,
            )
        else:
            # Opus repair failed, return original HTML
            logger.warning("Opus repair failed, returning original HTML")
            return CustomLayoutResult(
                html=html,
                success=True,
                error="Opus repair failed, returning original",
                latency_ms=(time.time() - start_time) * 1000,
            )

    def _clean_html_response(self, content: str) -> Optional[str]:
        """
        Clean and extract HTML from GPT response.
        
        GPT might wrap HTML in markdown code blocks or add explanations.
        This method extracts just the HTML.
        
        Args:
            content: Raw response from GPT-5.2
            
        Returns:
            Cleaned HTML string or None if extraction fails
        """
        if not content:
            return None
        
        html = content.strip()
        
        # Remove markdown code blocks if present
        if html.startswith("```html"):
            html = html[7:]
        elif html.startswith("```"):
            html = html[3:]
        
        if html.endswith("```"):
            html = html[:-3]
        
        html = html.strip()
        
        # Ensure it starts with DOCTYPE or <html>
        lower_html = html.lower()
        if not (lower_html.startswith("<!doctype") or lower_html.startswith("<html")):
            # Try to find the start of HTML
            doctype_idx = lower_html.find("<!doctype")
            html_idx = lower_html.find("<html")
            
            if doctype_idx >= 0:
                html = html[doctype_idx:]
            elif html_idx >= 0:
                html = html[html_idx:]
            else:
                return None
        
        return html

    def _extract_interactions_comment(self, html: str) -> Optional[str]:
        """
        Extract the INTERACTIONS comment from HTML if present.

        Args:
            html: HTML string that may contain <!-- INTERACTIONS: ... -->

        Returns:
            The interactions description or None if not found
        """
        if not html:
            return None

        import re
        # Match <!-- INTERACTIONS: ... --> comment
        match = re.search(r'<!--\s*INTERACTIONS:\s*(.*?)\s*-->', html, re.DOTALL | re.IGNORECASE)
        if match:
            return match.group(1).strip()
        return None

    def _is_valid_html_structure(self, html: str) -> bool:
        """
        Basic validation that the string looks like valid HTML.
        
        This is a quick check, not a full HTML parser validation.
        Playwright validation is used for thorough checking.
        
        Args:
            html: HTML string to validate
            
        Returns:
            True if it appears to be valid HTML structure
        """
        if not html:
            return False
        
        lower_html = html.lower()
        
        # Must have html tags
        has_html_open = "<html" in lower_html
        has_html_close = "</html>" in lower_html
        
        # Must have body (or at least content)
        has_body = "<body" in lower_html or "<!doctype" in lower_html
        
        # Basic length check (HTML should have some content)
        is_reasonable_length = len(html) > 100
        
        return (has_html_open or has_body) and has_html_close and is_reasonable_length
    
    async def _repair_html_with_fallback(
        self,
        invalid_html: str,
        validation_error: str,
        user_request: str,
    ) -> Optional[str]:
        """
        Attempt to repair invalid HTML using Gemini diagnosis + Codex-Max repair.

        Sprint 5.2.1: When Codex-Max generates invalid HTML, this method:
        1. Uses Gemini (fast, cheap) to diagnose the issue
        2. Uses Codex-Max to repair based on the diagnosis
        3. Validates the repaired HTML
        
        Args:
            invalid_html: The HTML that failed validation
            validation_error: Why it failed
            user_request: Original user request for context
            
        Returns:
            Repaired HTML string or None if repair failed
        """
        # Check if repair is enabled
        if not getattr(settings, 'HTML_REPAIR_ENABLED', True):
            logger.debug("HTML repair is disabled")
            return None
        
        max_retries = getattr(settings, 'HTML_REPAIR_MAX_RETRIES', 1)
        
        for attempt in range(max_retries):
            try:
                logger.info(f"HTML repair attempt {attempt + 1}/{max_retries}")
                
                # Step 1: Gemini diagnoses the issue (fast, cheap)
                diagnosis_prompt = build_html_diagnosis_prompt(invalid_html, validation_error)
                diagnosis_response = await gemini_provider.generate(
                    prompt=diagnosis_prompt,
                    system_prompt=get_diagnosis_system_prompt(),
                    temperature=0.1,
                    max_tokens=256,
                )
                
                if not diagnosis_response.success:
                    logger.warning(f"Gemini diagnosis failed: {diagnosis_response.error}")
                    continue
                
                diagnosis = diagnosis_response.content.strip()
                logger.info(f"HTML diagnosis: {diagnosis}")
                
                # Step 2: Gemini 3 Pro repairs based on diagnosis (Sprint 9)
                repair_prompt = build_html_repair_prompt(
                    html=invalid_html,
                    diagnosis=diagnosis,
                    original_request=user_request,
                )
                repair_response = await gemini_provider.generate(
                    prompt=repair_prompt,
                    system_prompt=get_repair_system_prompt(),
                    temperature=0.2,
                    max_tokens=16384,
                    model_override=settings.GEMINI_PRO_MODEL,
                    use_thinking=True,
                    thinking_level="HIGH",
                )

                if not repair_response.success:
                    logger.warning(f"Gemini repair failed: {repair_response.error}")
                    continue
                
                # Step 3: Clean and validate repaired HTML
                repaired_html = self._clean_html_response(repair_response.content)
                
                if repaired_html and self._is_valid_html_structure(repaired_html):
                    logger.info(f"HTML repair successful on attempt {attempt + 1}")
                    return repaired_html
                else:
                    logger.warning(f"Repaired HTML still invalid on attempt {attempt + 1}")
                    # Update invalid_html for next attempt
                    if repaired_html:
                        invalid_html = repaired_html
                    
            except Exception as e:
                logger.error(f"HTML repair error on attempt {attempt + 1}: {e}", exc_info=True)
                continue
        
        logger.error(f"HTML repair failed after {max_retries} attempts")
        return None

    async def _debug_css_interactivity(
        self,
        html: str,
    ) -> Optional[str]:
        """
        Debug and fix CSS interactivity issues in generated HTML.

        Sprint 5.2.2: Two-pass approach - always runs after generation.
        Uses Gemini for diagnosis (fast) and Codex-Max for repair.

        Args:
            html: The HTML from Pass 1 (Codex-Max generation)

        Returns:
            Debugged HTML or original if no issues found
        """
        if not html:
            return None

        logger.info("Pass 2: Debugging CSS interactivity")

        # Extract expected interactions from HTML comment (if present)
        expected_interactions = self._extract_interactions_comment(html)
        if expected_interactions:
            logger.info(f"Expected interactions: {expected_interactions[:100]}...")

        try:
            # Step 1: Gemini diagnoses CSS interactivity issues (fast, cheap)
            diagnosis_prompt = build_css_debug_diagnosis_prompt(html, expected_interactions)
            diagnosis_response = await gemini_provider.generate(
                prompt=diagnosis_prompt,
                system_prompt=get_css_debug_diagnosis_system_prompt(),
                temperature=0.1,
                max_tokens=256,
            )

            if not diagnosis_response.success:
                logger.warning(f"CSS diagnosis failed: {diagnosis_response.error}")
                return html  # Return original if diagnosis fails

            diagnosis = diagnosis_response.content.strip()
            logger.info(f"CSS diagnosis: {diagnosis}")

            # If no issues found, return original HTML
            if "NO ISSUES" in diagnosis.upper():
                logger.info("Pass 2: No CSS interactivity issues found")
                return html

            # Step 2: Gemini 3 Pro fixes the issues (Sprint 9)
            logger.info("Pass 2: Fixing CSS interactivity bugs with Gemini 3 Pro")
            repair_prompt = build_css_debug_repair_prompt(html, diagnosis)

            repair_response = await gemini_provider.generate(
                prompt=repair_prompt,
                system_prompt=get_css_debug_repair_system_prompt(),
                temperature=0.2,
                max_tokens=16384,
                model_override=settings.GEMINI_PRO_MODEL,
                use_thinking=True,
                thinking_level="HIGH",
            )

            if not repair_response.success:
                logger.warning(f"Gemini CSS repair failed: {repair_response.error}")
                return html  # Return original if repair fails

            repaired_html = self._clean_html_response(repair_response.content)
            logger.info(f"Pass 2 completed in {repair_response.latency_ms:.0f}ms")

            return repaired_html if repaired_html else html

        except Exception as e:
            logger.error(f"CSS debug error: {e}", exc_info=True)
            return html  # Return original on any error

    async def repair_validation_errors(
        self,
        html: str,
        validation_result: ValidationResult,
        user_request: str,
    ) -> Optional[str]:
        """
        Repair HTML that failed Playwright validation.

        Sprint 5.3: When layout_validator.validate() fails, this method:
        1. Uses Gemini (fast) to diagnose the validation errors
        2. Uses GPT Codex-Max to repair based on the diagnosis
        3. Returns repaired HTML or None if repair failed

        Args:
            html: The HTML that failed validation
            validation_result: ValidationResult with errors and behavior_report
            user_request: Original user request for context

        Returns:
            Repaired HTML string or None if repair failed
        """
        if not getattr(settings, 'HTML_REPAIR_ENABLED', True):
            logger.debug("HTML repair is disabled")
            return None

        max_retries = getattr(settings, 'VALIDATION_REPAIR_MAX_RETRIES', 2)

        # Prepare behavior report string if available
        behavior_report_str = None
        if validation_result.behavior_report and validation_result.behavior_report.phase_executed:
            behavior_report_str = validation_result.behavior_report.to_diagnosis_string()

        current_html = html

        for attempt in range(max_retries):
            try:
                logger.info(f"Validation repair attempt {attempt + 1}/{max_retries}")

                # Step 1: Gemini diagnoses the validation errors (fast, cheap)
                diagnosis_prompt = build_validation_diagnosis_prompt(
                    html=current_html,
                    validation_errors=validation_result.errors,
                    behavior_report_str=behavior_report_str,
                )

                diagnosis_response = await gemini_provider.generate(
                    prompt=diagnosis_prompt,
                    system_prompt=get_validation_diagnosis_system_prompt(),
                    temperature=0.1,
                    max_tokens=512,
                )

                if not diagnosis_response.success:
                    logger.warning(f"Gemini diagnosis failed: {diagnosis_response.error}")
                    continue

                diagnosis = diagnosis_response.content.strip()
                logger.info(f"Validation diagnosis: {diagnosis}")

                # Step 2: Gemini 3 Pro repairs based on diagnosis (Sprint 9)
                repair_prompt = build_validation_repair_prompt(
                    html=current_html,
                    diagnosis=diagnosis,
                    validation_errors=validation_result.errors,
                    user_request=user_request,
                )

                repair_response = await gemini_provider.generate(
                    prompt=repair_prompt,
                    system_prompt=get_validation_repair_system_prompt(),
                    temperature=0.2,
                    max_tokens=16384,
                    model_override=settings.GEMINI_PRO_MODEL,
                    use_thinking=True,
                    thinking_level="HIGH",
                )

                if not repair_response.success:
                    logger.warning(f"Gemini repair failed: {repair_response.error}")
                    continue

                # Step 3: Clean and validate repaired HTML
                repaired_html = self._clean_html_response(repair_response.content)

                if repaired_html and self._is_valid_html_structure(repaired_html):
                    logger.info(f"Validation repair produced valid HTML on attempt {attempt + 1}")
                    return repaired_html
                else:
                    logger.warning(f"Repaired HTML still invalid structure on attempt {attempt + 1}")
                    if repaired_html:
                        current_html = repaired_html

            except Exception as e:
                logger.error(f"Validation repair error on attempt {attempt + 1}: {e}", exc_info=True)
                continue

        logger.error(f"Validation repair failed after {max_retries} attempts")
        return None

    async def generate_and_validate_html(
        self,
        scene: Dict[str, Any],
        user_request: str,
        layout_type: Optional[str] = None,
    ) -> CustomLayoutResult:
        """
        Generate HTML and validate with visual validation pipeline.

        Sprint 6: Uses the new 7-phase visual validation system that
        compares screenshots before/after clicks to detect real changes.

        Flow:
        1. Generate HTML with Opus 4.5
        2. Validate with VisualValidator (screenshot comparison)
        3. If fails, repair with DirectFixer (Codex-Max)
        4. Re-validate repaired HTML
        5. Return result

        Args:
            scene: SceneGraph dictionary
            user_request: Original user request
            layout_type: Optional layout type hint (trivia, dashboard, etc.)

        Returns:
            CustomLayoutResult with validated HTML
        """
        start_time = time.time()

        # Check if visual validation is enabled
        use_visual_validation = getattr(settings, 'VISUAL_VALIDATION_ENABLED', True)

        # Step 1: Generate HTML
        result = await self.generate_html(scene, user_request)

        if not result.success or not result.html:
            return result

        if not use_visual_validation:
            logger.info("Visual validation disabled, returning generated HTML")
            return result

        html = result.html

        # Detect layout type from scene if not provided
        if not layout_type:
            layout_type = self._detect_layout_type_from_scene(scene)

        logger.info(f"Starting visual validation (layout_type={layout_type})")

        # Step 2: Validate with VisualValidator
        contract = ValidationContract(
            html=html,
            layout_type=layout_type,
            visual_change_threshold=getattr(settings, 'VISUAL_CHANGE_THRESHOLD', 0.02),
            blank_page_threshold=getattr(settings, 'BLANK_PAGE_THRESHOLD', 0.95),
            max_inputs_to_test=getattr(settings, 'MAX_INPUTS_TO_TEST', 10),
            stabilization_ms=getattr(settings, 'INTERACTION_STABILIZATION_MS', 300),
        )

        validation_result = await visual_validator.validate(contract)

        if validation_result.valid:
            logger.info(
                f"Visual validation passed - "
                f"inputs={validation_result.inputs_responsive}/{validation_result.inputs_tested}, "
                f"confidence={validation_result.confidence:.2f}"
            )
            return CustomLayoutResult(
                html=html,
                success=True,
                error=None,
                latency_ms=(time.time() - start_time) * 1000,
            )

        # Step 3: Validation failed - attempt repair
        logger.warning(
            f"Visual validation failed: {validation_result.failure_summary}"
        )

        max_repair_attempts = getattr(settings, 'VALIDATION_REPAIR_MAX_RETRIES', 2)

        # Sprint 7: Check if vision repair is enabled
        use_vision_repair = getattr(settings, 'VISION_REPAIR_ENABLED', True)

        # Track original HTML and validation for consistent repair attempts
        # IMPORTANT: Always repair from original, not from failed repair attempts
        original_html = html
        original_validation_result = validation_result
        original_inputs_tested = validation_result.inputs_tested
        original_inputs_responsive = validation_result.inputs_responsive

        # Track best repair attempt (in case all fail, return the best one)
        best_repaired_html = None
        best_responsive_count = 0

        # Sprint 8: Track failed repair attempts to avoid repeating mistakes
        failed_attempts: list[FailedRepairAttempt] = []

        # Sprint 11: Track current validation results for diagnosis
        # This gets updated after each re-validation so Flash sees the CURRENT state
        current_validation_result = validation_result

        for attempt in range(max_repair_attempts):
            logger.info(f"Visual repair attempt {attempt + 1}/{max_repair_attempts}")

            # Sprint 7: Use vision repair if screenshot is available
            # ALWAYS repair from ORIGINAL HTML to avoid accumulating errors in code
            # Sprint 11: BUT use CURRENT validation results for diagnosis (sees updated state)
            # Sprint 8: Pass failed_attempts so fixer learns from previous failures
            screenshot = current_validation_result.page_screenshot or original_validation_result.page_screenshot

            if use_vision_repair and screenshot:
                logger.info(
                    f"Using vision-enhanced repair with screenshot "
                    f"(cycle {attempt + 1}, current state: {current_validation_result.inputs_responsive}/{current_validation_result.inputs_tested})"
                )
                repaired_html = await direct_fixer.repair_with_vision(
                    html=original_html,  # Always from original to avoid error accumulation
                    sandbox_result=current_validation_result,  # Sprint 11: Use CURRENT validation
                    user_request=user_request,
                    screenshot=screenshot,
                    failed_attempts=failed_attempts,
                )
            else:
                # Fallback to text-only repair (Sonnet 4.5)
                repaired_html = await direct_fixer.repair(
                    html=original_html,  # Always from original
                    sandbox_result=current_validation_result,  # Sprint 11: Use CURRENT validation
                    user_request=user_request,
                    failed_attempts=failed_attempts,
                )

            if not repaired_html:
                logger.warning(f"Repair attempt {attempt + 1} failed to produce HTML")
                # Sprint 8: Record failed attempt
                failed_attempts.append(FailedRepairAttempt(
                    attempt_number=attempt + 1,
                    failure_reason="no_html",
                    inputs_before=original_inputs_tested,
                    inputs_after=0,
                    responsive_before=original_inputs_responsive,
                    responsive_after=0,
                ))
                continue

            # Save repaired HTML for debugging
            save_html_for_debug(repaired_html, suffix=f"repaired_{attempt + 1}")

            # Re-validate repaired HTML
            repair_contract = ValidationContract(
                html=repaired_html,
                layout_type=layout_type,
                visual_change_threshold=contract.visual_change_threshold,
                blank_page_threshold=contract.blank_page_threshold,
                max_inputs_to_test=contract.max_inputs_to_test,
                stabilization_ms=contract.stabilization_ms,
            )

            repair_validation = await visual_validator.validate(repair_contract)

            # Check for destructive repair: did we lose interactive elements?
            if repair_validation.inputs_tested < original_inputs_tested:
                logger.warning(
                    f"Repair attempt {attempt + 1} REJECTED: destructive repair detected. "
                    f"Original had {original_inputs_tested} inputs, repair has {repair_validation.inputs_tested}. "
                    f"Fixer removed/hid interactive elements instead of fixing them."
                )
                # Sprint 8: Record destructive attempt with CSS rules tried
                css_rules_tried = extract_state_css_rules(repaired_html)
                failed_attempts.append(FailedRepairAttempt(
                    attempt_number=attempt + 1,
                    failure_reason="destructive",
                    inputs_before=original_inputs_tested,
                    inputs_after=repair_validation.inputs_tested,
                    responsive_before=original_inputs_responsive,
                    responsive_after=repair_validation.inputs_responsive,
                    key_changes_attempted=css_rules_tried,
                ))
                continue

            # Track best attempt (most responsive inputs)
            if repair_validation.inputs_responsive > best_responsive_count:
                best_repaired_html = repaired_html
                best_responsive_count = repair_validation.inputs_responsive

            if repair_validation.valid:
                logger.info(
                    f"Repair successful on attempt {attempt + 1} - "
                    f"inputs={repair_validation.inputs_responsive}/{repair_validation.inputs_tested}"
                )
                return CustomLayoutResult(
                    html=repaired_html,
                    success=True,
                    error=None,
                    latency_ms=(time.time() - start_time) * 1000,
                )

            logger.warning(
                f"Repair attempt {attempt + 1} improved but not enough: "
                f"{repair_validation.inputs_responsive}/{repair_validation.inputs_tested} responsive"
            )
            # Sprint 8: Record insufficient attempt with CSS rules tried
            css_rules_tried = extract_state_css_rules(repaired_html)
            failed_attempts.append(FailedRepairAttempt(
                attempt_number=attempt + 1,
                failure_reason="insufficient",
                inputs_before=original_inputs_tested,
                inputs_after=repair_validation.inputs_tested,
                responsive_before=original_inputs_responsive,
                responsive_after=repair_validation.inputs_responsive,
                key_changes_attempted=css_rules_tried,
            ))

            # Sprint 11: Update current validation for next cycle
            # Flash will now see the UPDATED state (which elements now work vs still fail)
            current_validation_result = repair_validation
            logger.info(
                f"Sprint 11: Next cycle will diagnose from updated state "
                f"({repair_validation.inputs_responsive}/{repair_validation.inputs_tested} responsive)"
            )

        # All repair attempts failed - return best effort or fail
        logger.error(
            f"Visual validation failed after {max_repair_attempts} repair attempts. "
            f"Best responsive count: {best_responsive_count}/{original_inputs_tested}"
        )

        # If we have a best attempt that improved things, return it
        if best_repaired_html and best_responsive_count > 0:
            return CustomLayoutResult(
                html=best_repaired_html,
                success=True,  # Partial success
                error=f"Validation incomplete: {original_validation_result.failure_summary}",
                latency_ms=(time.time() - start_time) * 1000,
            )

        return CustomLayoutResult(
            html=None,
            success=False,
            error=f"Visual validation failed: {original_validation_result.failure_summary}",
            latency_ms=(time.time() - start_time) * 1000,
        )

    def _detect_layout_type_from_scene(self, scene: Dict[str, Any]) -> str:
        """
        Detect layout type from SceneGraph.

        Args:
            scene: SceneGraph dictionary

        Returns:
            Layout type string
        """
        # Check layout intent
        layout = scene.get("layout", {})
        intent = layout.get("intent", "").lower()

        if intent in ("trivia", "quiz"):
            return "trivia"
        elif intent in ("game", "mini_game"):
            return "mini_game"
        elif intent in ("dashboard",):
            return "dashboard"

        # Check components for hints
        components = scene.get("components", [])
        for comp in components:
            comp_type = comp.get("type", "").lower()
            if "trivia" in comp_type or "quiz" in comp_type:
                return "trivia"
            elif "game" in comp_type:
                return "mini_game"
            elif "chart" in comp_type or "metric" in comp_type:
                return "dashboard"

        return "unknown"


# ---------------------------------------------------------------------------
# SINGLETON INSTANCE
# ---------------------------------------------------------------------------
custom_layout_service = CustomLayoutService()
